using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Uno.RoslynHelpers;
using Uno.SourceGeneration;

namespace ReFit.Generator
{
    public class RefitGenerator : SourceGenerator
    {
        private Dictionary<string, INamedTypeSymbol> refitAttributes;

        public override void Execute(SourceGeneratorContext context)
        {
            Debugger.Launch();

            // Search for the GeneratedPropertyAttribute symbol
            refitAttributes =
                new[] { "Get", "Head", "Post", "Put", "Delete", "Patch", "Options" }
                .ToDictionary(a => a, a => context.Compilation.GetTypeByMetadataName($"Refit.{a}Attribute"));

            // Search in all types defined in the current compilation (not in the dependents)
            var query = from typeSymbol in context.Compilation.SourceModule.GlobalNamespace.GetNamespaceTypes()
                        where typeSymbol.TypeKind == TypeKind.Interface

                        from property in typeSymbol.GetAllInterfaceMethods().Distinct()

                        // Find the attribute on the method
                        let info = refitAttributes.Values.Select(a => property.FindAttributeFlattened(a)).ToArray()
                        where info.Any()

                        // Group properties by type
                        group property by typeSymbol into g
                        select g;

            GeneratePreserve(context);

            foreach(var type in query)
            {
                var builder = new IndentedStringBuilder();

                builder.AppendLineInvariant("using System;");
                builder.AppendLineInvariant("using System.ComponentModel;");
                builder.AppendLineInvariant("using System.Net.Http;");

                using (builder.BlockInvariant($"namespace {type.Key.ContainingNamespace}"))
                {
                    builder.AppendLineInvariant($"using {context.Compilation.AssemblyName}.RefitInternalGenerated;");

                    builder.AppendLineInvariant("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
                    builder.AppendLineInvariant("[global::System.Diagnostics.DebuggerNonUserCode]");
                    builder.AppendLineInvariant("[Preserve]");
                    builder.AppendLineInvariant("[global::System.Reflection.Obfuscation(Exclude=true)]");

                    string buildConstraints()
                    {
                        var sb = new StringBuilder();

                        foreach(var constraint in type.Key.TypeArguments.OfType<ITypeParameterSymbol>())
                        {
                            var constraintList = new List<string>();

                            var typeConstaints = constraint.ConstraintTypes.Select(t => t.ToDisplayString());
                            if (constraint.ConstraintTypes.Any())
                            {
                                constraintList.Add(string.Join(", ", typeConstaints));
                            }

                            if (constraint.HasReferenceTypeConstraint)
                            {
                                constraintList.Add($"class");
                            }
                            if (constraint.HasConstructorConstraint)
                            {
                                constraintList.Add($"new()");
                            }
                            if (constraint.HasValueTypeConstraint)
                            {
                                constraintList.Add($"struct");
                            }

                            if (constraintList.Count != 0)
                            {
                                sb.Append($" where {constraint.Name} : " + string.Join(", ", constraintList));
                            }
                        }

                        return sb.ToString();
                    }

                    var className = $"AutoGenerated{ type.Key.Name}";

                    var genericParameters = type.Key.TypeArguments.Length != 0
                        ? "<" + string.Join(", ", type.Key.TypeArguments.Select(a => a.Name)) + ">"
                        : "";

                    using (builder.BlockInvariant($"partial class {className}{genericParameters} : {type.Key.ToDisplayString()} {buildConstraints()}"))
                    {
                        builder.AppendLineInvariant("public HttpClient Client {{ get; protected set; }}");
                        builder.AppendLineInvariant("readonly IRequestBuilder requestBuilder;");

                        using (builder.BlockInvariant($"public {className}(HttpClient client, IRequestBuilder requestBuilder)"))
                        {
                            builder.AppendLineInvariant("Client = client;");
                            builder.AppendLineInvariant("this.requestBuilder = requestBuilder;");
                        }

                        foreach (var methodInfo in type)
                        {
                            var methodArguments = string.Join(", ", methodInfo.Parameters.Select(p => $"{p.Type.ToDisplayString()} {p.Name}"));

                            using (builder.BlockInvariant($"{methodInfo.ReturnType} {methodInfo.ReceiverType.ToDisplayString()}.{methodInfo.Name}({methodArguments})"))
                            {
                                var argumentsNames = string.Join(", ", methodInfo.Parameters.Select(p => p.Name));
                                builder.AppendLineInvariant("{0}", $"var arguments = new object[] {{ {argumentsNames} }};");

                                var argumentsTypes = string.Join(", ", methodInfo.Parameters.Select(p => $"typeof({p.Type.ToDisplayString()})"));
                                builder.AppendLineInvariant("{0}", $"var func = requestBuilder.BuildRestResultFuncForMethod(\"{methodInfo.Name}\", new Type[]{{ {argumentsTypes} }});");
                                builder.AppendLineInvariant($"return ({methodInfo.ReturnType})func(Client, arguments);");
                            }

                            builder.AppendLineInvariant("");
                        }
                    }
                }

                var sanitizedName = type.Key.ToDisplayString().Replace(".", "_").Replace("+", "_");
                context.AddCompilationUnit(sanitizedName, builder.ToString());
            }
        }

        void GeneratePreserve(SourceGeneratorContext context)
        {
            var builder = new IndentedStringBuilder();

            builder.AppendLineInvariant("// <auto-generated />");
            builder.AppendLineInvariant("using System;");

            builder.AppendLineInvariant("#pragma warning disable");

            using (builder.BlockInvariant($"namespace {context.Compilation.AssemblyName}.RefitInternalGenerated"))
            {
                builder.AppendLineInvariant("[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]");
                builder.AppendLineInvariant("[AttributeUsage (AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Interface | AttributeTargets.Delegate)]");

                using (builder.BlockInvariant("sealed class PreserveAttribute : Attribute"))
                {
                    builder.AppendLineInvariant("public bool AllMembers;");
                    builder.AppendLineInvariant("public bool Conditional;");

                }
            }

            context.AddCompilationUnit("RefitPreserveAttribute", builder.ToString());
        }
    }
}
